'use strict';

var fs = require('fs');
var path = require('path');

// we don't want to overwhelm the file system, and some unix systems
// limit the number of open file handles, so we queue requests beyond
// this limit
const MAX_PARALLEL_TASKS = 20;
function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch (ex) {
    return undefined;
  }
}
async function findPackageLocations(cwd) {
  return new Promise((resolve, reject) => {
    const pkgLocations = new Map();
    let inFlight = 0;
    let pending = [];
    let errored = false;
    function task(fn) {
      if (errored) return;
      if (inFlight === MAX_PARALLEL_TASKS) {
        pending.push(fn);
      } else {
        inFlight++;
        let called = false;
        fn((err) => {
          if (called) throw new Error(`Called callback multiple times!!!`);
          called = true;
          if (errored) return;
          if (err) {
            errored = true;
            reject(err);
            return;
          }
          inFlight--;
          if (pending.length) {
            task(pending.pop());
          } else if (inFlight === 0) {
            resolve(
              new Map([...pkgLocations].sort(([a], [b]) => (a < b ? -1 : 1))),
            );
          }
        });
      }
    }
    function testDirectory(sourceDirectory, dir) {
      const node_modules = path.join(dir, 'node_modules');
      task((cb) => {
        fs.readdir(node_modules, (err, directoryNames) => {
          if (err) {
            cb();
            return;
          }
          for (const directoryName of directoryNames) {
            if (directoryName[0] === '@') {
              const scopeDir = path.join(node_modules, directoryName);
              task((cb) => {
                fs.readdir(scopeDir, (err, directoryNames) => {
                  if (err) {
                    cb();
                    return;
                  }
                  for (const directoryName of directoryNames) {
                    testDirectory(
                      sourceDirectory,
                      path.join(scopeDir, directoryName),
                    );
                  }
                  cb();
                });
              });
            } else if (directoryName !== '.bin' && directoryName !== '.cache') {
              testDirectory(
                sourceDirectory,
                path.join(node_modules, directoryName),
              );
            }
          }
          cb();
        });
      });
      const pkgFileName = path.join(dir, 'package.json');
      task((cb) => {
        fs.readFile(pkgFileName, 'utf8', (err, result) => {
          if (err) {
            cb();
            return;
          }
          const pkg = tryParse(result);
          if (!pkg || typeof pkg !== 'object') {
            cb();
            return;
          }
          const name = pkg.name;
          const version = pkg.version;
          if (
            typeof name !== 'string' ||
            typeof version !== 'string' ||
            !name ||
            !version
          ) {
            cb();
            return;
          }
          const relativePackageDirectory = path
            .relative(sourceDirectory, dir)
            .split(path.win32.sep)
            .join(path.posix.sep);
          fs.realpath(dir, (err, resolvedPackageDirectory) => {
            if (err) {
              cb(err);
              return;
            }
            const id = `${name}@${version}`;
            const existingLocation = pkgLocations.get(id);
            if (
              existingLocation &&
              // always prefer locations that are closer to the cwd
              (existingLocation.sourceDirectory.split(path.sep).length >
                sourceDirectory.split(path.sep).length ||
                // always prefer directories that are less deeply nested in node_modules
                (existingLocation.sourceDirectory.split(path.sep).length ===
                  sourceDirectory.split(path.sep).length &&
                  existingLocation.relativePackageDirectory.split(path.sep)
                    .length < relativePackageDirectory.split(path.sep).length))
            ) {
              // the existing package is a better match
              existingLocation.alternativeLocations.push({
                sourceDirectory,
                relativePackageDirectory,
                resolvedPackageDirectory,
              });
            } else if (existingLocation) {
              const {
                alternativeLocations,
                name,
                version,
                ...existingLocationProps
              } = existingLocation;
              pkgLocations.set(id, {
                name,
                version,
                sourceDirectory,
                relativePackageDirectory,
                resolvedPackageDirectory,
                alternativeLocations: [
                  ...alternativeLocations,
                  existingLocationProps,
                ],
              });
            } else {
              pkgLocations.set(id, {
                name,
                version,
                sourceDirectory,
                relativePackageDirectory,
                resolvedPackageDirectory,
                alternativeLocations: [],
              });
            }
            cb();
          });
        });
      });
    }
    task((cb) => {
      fs.realpath(cwd, (err, resolvedPath) => {
        if (err) {
          cb(err);
          return;
        }
        testDirectory(resolvedPath, resolvedPath);
        let nextParent = resolvedPath;
        while (nextParent && path.dirname(nextParent) !== nextParent) {
          nextParent = path.dirname(nextParent);
          testDirectory(nextParent, nextParent);
        }
        cb();
      });
    });
  });
}

module.exports = findPackageLocations;
