"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const path_1 = require("path");
const fs_1 = require("fs");
const crypto_1 = require("crypto");
const http_1 = require("http");
const sucrase_1 = require("sucrase");
const mime_1 = require("mime");
const bundle_1 = __importDefault(require("@start-dev/bundle"));
const rewrite_imports_1 = __importDefault(require("@start-dev/rewrite-imports"));
const find_package_locations_1 = __importDefault(require("@start-dev/find-package-locations"));
const get_package_exports_1 = __importDefault(require("@start-dev/get-package-exports"));
const chalk_1 = __importDefault(require("chalk"));
const server_1 = __importDefault(require("@start-dev/websocket-rpc/server"));
const find_cache_dir_1 = __importDefault(require("find-cache-dir"));
const rimraf_1 = __importDefault(require("rimraf"));
const CSRF_TOKEN = crypto_1.randomBytes(128).toString('base64');
const FRAME_DIRECTORY = path_1.resolve(`${__dirname}/../app`);
const htmlFileName = path_1.join(FRAME_DIRECTORY, 'index.html');
function createDevServer({ appDirectory, appEntrypoint = 'index.js', cacheDirectory: $cacheDirectory, portNumber, packageExportsOverrides, }) {
    var _a;
    const start = Date.now();
    const fullAppEntrypointPath = path_1.resolve(appDirectory, appEntrypoint);
    const relativeAppEntrypointPath = path_1.relative(appDirectory, fullAppEntrypointPath);
    if (relativeAppEntrypointPath.startsWith('.')) {
        throw new Error(`The app entrypoint "${fullAppEntrypointPath}" must be inside the app directory, "${appDirectory}"`);
    }
    const builtinDependencies = {
        '@start-dev/app': `/app/${relativeAppEntrypointPath.replace(/\\/g, '/')}`,
    };
    const ORIGIN = `http://localhost:${portNumber}`;
    const DISABLE_CACHE = process.env.DISABLE_CACHE === 'true';
    const cacheDirectory = (_a = $cacheDirectory !== null && $cacheDirectory !== void 0 ? $cacheDirectory : find_cache_dir_1.default({
        name: 'start-dev',
        cwd: appDirectory,
        create: true,
    })) !== null && _a !== void 0 ? _a : path_1.resolve('.start-dev-cache');
    const APP_EXTENSIONS = [
        '',
        '.js',
        '.jsx',
        '.mjs',
        '.cjs',
        '.ts',
        '.tsx',
        '/index.js',
        '/index.jsx',
        '/index.mjs',
        '/index.cjs',
        '/index.ts',
        '/index.tsx',
    ];
    const PACKAGE_EXTENSIONS = [
        '',
        '.js',
        '.jsx',
        '.mjs',
        '.cjs',
        '/index.js',
        '/index.jsx',
        '/index.mjs',
        '/index.cjs',
    ];
    const packageExportOverrides = {
        scheduler: { '.': './', './tracing': './tracing.js' },
        ...packageExportsOverrides,
    };
    const packageExportsByDirectory = new Map();
    async function getPackageExportsCached(directory, packageID) {
        const cached = packageExportsByDirectory.get(directory);
        if (cached)
            return await cached;
        const packageName = packageID.split('@').slice(0, -1).join('@');
        const fresh = get_package_exports_1.default(directory, {
            overrideExports: packageExportOverrides[packageName],
            allowedExportKeys: ['browser', 'module', 'import', 'default'],
        });
        packageExportsByDirectory.set(directory, fresh);
        return await fresh;
    }
    let packageLocationsPromise;
    // id is of the form "name@version"
    async function getPackageLocationsCached() {
        if (packageLocationsPromise) {
            return await packageLocationsPromise;
        }
        try {
            packageLocationsPromise = find_package_locations_1.default(appDirectory);
            return await packageLocationsPromise;
        }
        catch (ex) {
            packageLocationsPromise = undefined;
            throw ex;
        }
    }
    async function getPackageLocationCached(id) {
        return (await getPackageLocationsCached()).get(id);
    }
    function warnTimeout(p, time, message) {
        const t = setTimeout(() => {
            console.warn(message);
        }, time);
        p.then(() => clearTimeout(t), () => clearTimeout(t));
        return p;
    }
    async function bundlePackage(packageID) {
        const bundledDirectory = path_1.join(cacheDirectory, packageID);
        if (await fs_1.promises.stat(bundledDirectory).then((s) => s.isDirectory(), () => false)) {
            if (DISABLE_CACHE) {
                await new Promise((resolve, reject) => rimraf_1.default(bundledDirectory, (err) => {
                    if (err)
                        reject(err);
                    else
                        resolve();
                }));
            }
            else {
                return { bundledDirectory };
            }
        }
        const packageDirectory = await warnTimeout(getPackageLocationCached(packageID), 500, `getPackageLocationCached(${packageID}) has taken over 500ms!`);
        if (!packageDirectory) {
            return null;
        }
        const inputs = {};
        for (const e of await warnTimeout(getPackageExportsCached(packageDirectory.resolvedPackageDirectory, packageID), 500, `getPackageExportsCached(${packageID}) has taken over 500ms!`)) {
            inputs[`${e.exportName.replace(/\.js$/, '') || 'index'}`] =
                e.resolvedPath;
        }
        await warnTimeout(bundle_1.default(inputs, bundledDirectory), 5000, `bundleDependency(${packageID}) has taken over 5 seconds!`);
        return { bundledDirectory };
    }
    const bundledPackagesCache = new Map();
    async function bundlePackageCached(packageID) {
        const cached = bundledPackagesCache.get(packageID);
        if (cached)
            return await cached;
        const fresh = bundlePackage(packageID);
        bundledPackagesCache.set(packageID, fresh);
        Promise.race([
            fresh.then(() => true),
            new Promise((r) => setTimeout(() => r(false), 4000)),
        ])
            .then((result) => {
            if (!result) {
                console.warn(`${packageID} has still not fnished bundling after 4 seconds`);
            }
        })
            .catch(() => {
            // this error is reported elsewhere
        });
        return await fresh;
    }
    // GET _csrf => CSRF TOKEN
    // POST _api => API calls
    // GET /app/* => get modules from the actual app
    // GET /frame/* => get modules from the pre-provided frame
    // GET /packages/* => get packages
    // GET /dependencies/* => get package dependencies
    const server = http_1.createServer(async (req, res) => {
        var _a;
        // console.log(chalk.gray(`${req.method} ${req.url}`));
        const originalEnd = res.end;
        const start = Date.now();
        res.end = (...args) => {
            const time = Date.now() - start;
            console.info(`${res.statusCode === 304
                ? chalk_1.default.green('304')
                : res.statusCode >= 400
                    ? chalk_1.default.red(`${res.statusCode}`)
                    : chalk_1.default.blue(`${res.statusCode}`)} ${req.method} ${req.url} in ${time < 10
                ? chalk_1.default.green(`${time}ms`)
                : time < 100
                    ? chalk_1.default.yellow(`${time}ms`)
                    : chalk_1.default.red(`${time}ms`)}`);
            return originalEnd.call(res, ...args);
        };
        const referer = req.headers['referer'];
        let refererURL = null;
        try {
            refererURL = referer !== undefined ? new url_1.URL(referer) : null;
        }
        catch (ex) {
            // ignore error parsing referer
        }
        if (req.method === 'POST' && req.url === '/_csrf') {
            if (!refererURL || refererURL.origin !== ORIGIN) {
                res.statusCode = 400;
                res.end(`Invalid referer for CSRF request, expected ${ORIGIN}`);
                return;
            }
            res.setHeader('Content-Type', 'text/javascript');
            res.end(`while(true);console.log(${JSON.stringify(CSRF_TOKEN)})`);
            return;
        }
        if (req.method !== 'GET') {
            res.statusCode = 403;
            res.end(`Unexpected POST request`);
            return;
        }
        try {
            if (req.url.startsWith('/app/')) {
                if (req.url.endsWith('.js')) {
                    for (const ext of ['.js', '.jsx', '.ts', '.tsx']) {
                        const path = path_1.join(appDirectory, req.url.substr('/app/'.length)).replace(/\.js$/, ext);
                        if (await servePath(path, req, res)) {
                            return;
                        }
                    }
                }
                const path = path_1.join(appDirectory, req.url.substr('/app/'.length));
                const stat = await fs_1.promises
                    .stat(path)
                    .catch((ex) => (ex.code === 'ENOENT' ? null : Promise.reject(ex)));
                if (stat) {
                    const etag = stat.mtime.toISOString();
                    if (handledUsingCache(etag, req, res))
                        return;
                    res.setHeader('Content-Type', mime_1.getType(path));
                    res.end(await fs_1.promises.readFile(path));
                    return;
                }
                res.statusCode = 404;
                res.end('File not found');
                return;
            }
            if (req.url.startsWith('/frame/')) {
                if (req.url.endsWith('.js')) {
                    for (const ext of ['.js', '.jsx', '.ts', '.tsx']) {
                        const path = path_1.join(FRAME_DIRECTORY, req.url.substr('/frame/'.length)).replace(/\.js$/, ext);
                        if (await servePath(path, req, res)) {
                            return;
                        }
                    }
                }
                const path = path_1.join(FRAME_DIRECTORY, req.url.substr('/frame/'.length));
                const stat = await fs_1.promises
                    .stat(path)
                    .catch((ex) => (ex.code === 'ENOENT' ? null : Promise.reject(ex)));
                if (stat) {
                    const etag = stat.mtime.toISOString();
                    if (handledUsingCache(etag, req, res))
                        return;
                    res.setHeader('Content-Type', mime_1.getType(path));
                    res.end(await fs_1.promises.readFile(path));
                    return;
                }
                res.statusCode = 404;
                res.end('File not found');
                return;
            }
            if (req.url.startsWith('/dependencies/')) {
                const path = req.url.substr('/dependencies/'.length).split('/');
                let parentID = path[0];
                let dep = path.slice(1);
                if (parentID.startsWith('@')) {
                    parentID += `/${dep[0]}`;
                    dep = dep.slice(1);
                }
                let childName = dep[0];
                let entrypoint = dep.slice(1);
                if (childName.startsWith('@')) {
                    childName += `/${entrypoint[0]}`;
                    entrypoint = entrypoint.slice(1);
                }
                let parentDirectory = parentID === '_'
                    ? appDirectory
                    : (_a = (await getPackageLocationCached(parentID))) === null || _a === void 0 ? void 0 : _a.resolvedPackageDirectory;
                if (!parentDirectory) {
                    res.statusCode = 404;
                    res.end(`Dependency not found`);
                    return;
                }
                let pkgStr = null;
                while (parentDirectory && pkgStr === null) {
                    pkgStr = await fs_1.promises
                        .readFile(path_1.join(parentDirectory, 'node_modules', childName, 'package.json'), 'utf8')
                        .catch(() => null);
                    if (parentDirectory === path_1.dirname(parentDirectory)) {
                        break;
                    }
                    parentDirectory = path_1.dirname(parentDirectory);
                }
                if (pkgStr === null) {
                    res.statusCode = 404;
                    res.end(`Dependency not found`);
                    return;
                }
                const pkg = JSON.parse(pkgStr);
                if (handledUsingCache(`${pkg.name}@${pkg.version}`, req, res))
                    return;
                const source = `/packages/${pkg.name}@${pkg.version}/${entrypoint.length
                    ? `${entrypoint.join('/').replace(/\.js$/, '')}`
                    : `index`}.js`;
                res.setHeader('Content-Type', 'text/javascript');
                res.end(`import * as p from '${source}';\nexport default p.default;\nexport * from '${source}';\n`);
                return;
            }
            if (req.url.startsWith('/packages/')) {
                if (handledUsingCache(req.url, req, res)) {
                    return;
                }
                const path = req.url.substr('/packages/'.length).split('/');
                let packageID = path[0];
                let entrypoint = path.slice(1);
                if (packageID.startsWith('@')) {
                    packageID += `/${entrypoint[0]}`;
                    entrypoint = entrypoint.slice(1);
                }
                const bundled = await bundlePackageCached(packageID);
                if (!bundled) {
                    res.statusCode = 404;
                    res.end('Could not find the requested package');
                    return;
                }
                if (await servePackageFile({
                    packageID,
                    packageDirectory: bundled.bundledDirectory,
                    entryPoint: entrypoint.join('/'),
                }, req, res)) {
                    return;
                }
                res.statusCode = 404;
                res.end('File not found');
                return;
            }
            const path = path_1.join(FRAME_DIRECTORY, req.url.substr(1));
            const stat = await fs_1.promises
                .stat(path)
                .catch((ex) => (ex.code === 'ENOENT' ? null : Promise.reject(ex)));
            if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
                const etag = stat.mtime.toISOString();
                if (handledUsingCache(etag, req, res))
                    return;
                res.setHeader('Content-Type', mime_1.getType(path));
                res.end(await fs_1.promises.readFile(path));
                return;
            }
            const etag = (await fs_1.promises.stat(htmlFileName)).mtime.toISOString();
            if (handledUsingCache(etag, req, res))
                return;
            res.setHeader('Content-Type', 'text/html');
            res.end(await fs_1.promises.readFile(htmlFileName));
        }
        catch (ex) {
            console.error(ex.stack);
            res.statusCode = 500;
            res.end('Internal sever error');
        }
    });
    const websocketServer = server_1.default({
        server,
        token: CSRF_TOKEN,
        clientName: 'client',
    });
    server.listen(portNumber, () => {
        // Prepopulate the cache. This cache typically takes ~200ms - 300ms to build,
        // and is by far the slowest part of the entire process of starting a start-dev
        // app
        getPackageLocationsCached()
            .catch(() => {
            // ignore this for now, it can be re-thrown when the locations are actually requested
        })
            .then(() => {
            const runningLine = `  Dashboard running: ${ORIGIN}  `;
            console.log(` -${'-'.repeat(runningLine.length)}-`);
            console.log(` |${' '.repeat(runningLine.length)}|`);
            console.log(` |  Dashboard running: ${chalk_1.default.cyan(ORIGIN)}  |`);
            console.log(` |${' '.repeat(runningLine.length)}|`);
            console.log(` -${'-'.repeat(runningLine.length)}-`);
            console.log(``);
            console.log(chalk_1.default.green(`Started in ${Date.now() - start} milliseconds`));
        });
    });
    function handledUsingCache(etag, req, res) {
        if (DISABLE_CACHE)
            return false;
        if (req.headers['if-none-match'] === etag) {
            res.statusCode = 304;
            res.end();
            return true;
        }
        res.setHeader('ETag', etag);
        return false;
    }
    async function servePath(path, req, res) {
        const stat = await fs_1.promises.stat(path).then((s) => (s.isFile() ? s : null), (ex) => (ex.code === 'ENOENT' ? null : Promise.reject(ex)));
        if (stat) {
            const isApiClient = /\.api\.[a-z]+$/.test(path);
            if (isApiClient) {
                const src = `import client from '/frame/api-client.js';\n${await websocketServer.getClient(path)}`;
                res.setHeader('Content-Type', 'text/javascript');
                res.end(src);
                return true;
            }
            const etag = stat.mtime.toISOString();
            if (handledUsingCache(etag, req, res))
                return true;
            const transformed = sucrase_1.transform(await fs_1.promises.readFile(path, 'utf8'), path.endsWith('.tsx')
                ? { transforms: ['typescript', 'jsx'], filePath: req.url }
                : path.endsWith('.ts')
                    ? { transforms: ['typescript'], filePath: req.url }
                    : { transforms: ['flow', 'jsx'], filePath: req.url }).code;
            const javaScript = await rewrite_imports_1.default({ source: transformed, name: path }, async (dep) => {
                if (dep[0] === '.') {
                    const absolutePath = await findPath(path_1.join(path_1.dirname(path), dep), APP_EXTENSIONS);
                    let relativePath = path_1.relative(FRAME_DIRECTORY, absolutePath);
                    if (relativePath[0] !== '.') {
                        return `/frame/${relativePath
                            .replace(/\.(jsx|ts|tsx)$/, '.js')
                            .replace(/\\/g, '/')}`;
                    }
                    relativePath = path_1.relative(appDirectory, absolutePath);
                    if (relativePath[0] !== '.') {
                        return `/app/${relativePath
                            .replace(/\.(jsx|ts|tsx)$/, '.js')
                            .replace(/\\/g, '/')}`;
                    }
                    if (relativePath[0] === '.') {
                        throw new Error(`Cannot import ${absolutePath} because it is outside the app directory.`);
                    }
                }
                if (dep in builtinDependencies) {
                    return builtinDependencies[dep];
                }
                return resolvePackage(dep, '_');
            });
            res.setHeader('Content-Type', 'text/javascript');
            res.end(javaScript);
            return true;
        }
        return false;
    }
    async function servePackageFile(file, _req, res) {
        const entryPointFileName = path_1.join(file.packageDirectory, file.entryPoint);
        const source = await fs_1.promises
            .readFile(entryPointFileName, 'utf8')
            .catch((ex) => (ex.code === 'ENOENT' ? null : Promise.reject(ex)));
        if (source !== null) {
            res.setHeader('Content-Type', 'text/javascript');
            res.end(await rewrite_imports_1.default({ source, name: entryPointFileName }, async (dep) => {
                if (dep[0] === '.') {
                    const absolutePath = await findPath(path_1.join(path_1.dirname(entryPointFileName), dep), PACKAGE_EXTENSIONS);
                    const relativePath = path_1.relative(file.packageDirectory, absolutePath);
                    if (relativePath[0] !== '.') {
                        return `/packages/${file.packageID}/${relativePath.replace(/\\/g, '/')}`;
                    }
                    if (relativePath[0] === '.') {
                        throw new Error(`Cannot import ${absolutePath} because it is outside the package directory.`);
                    }
                }
                if (dep in builtinDependencies) {
                    return builtinDependencies[dep];
                }
                return resolvePackage(dep, file.packageID);
            }));
            return true;
        }
        console.log(`NOT FOUND: ${entryPointFileName}`);
        return false;
    }
    function resolvePackage(importSpecifier, parentPackageID) {
        return `/dependencies/${parentPackageID}/${importSpecifier}`;
    }
    async function findPath(base, possibleExtensions) {
        for (const possibility of possibleExtensions) {
            const absolutePath = base.replace(/(?:\\|\/)$/, '') + possibility;
            if (await fs_1.promises.stat(absolutePath).then((s) => s.isFile(), () => false)) {
                return absolutePath;
            }
        }
        throw new Error(`Unable to resolve "${path_1.relative(process.cwd(), base)}", tried:\n\n${possibleExtensions
            .map((ext) => ` - ${base}${ext}`)
            .join('\n')}`);
    }
}
exports.default = createDevServer;
//# sourceMappingURL=index.js.map