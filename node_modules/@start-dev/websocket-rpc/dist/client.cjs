'use strict';

var types = require('./types-357c483b.cjs');

function createWebsocket(server, handlers) {
  const socket = new WebSocket(server);
  let openned = false;
  let closed = false;
  const api = {
    send(request) {
      socket.send(JSON.stringify(request));
    },
    isOpen: () => openned && !closed,
  };
  socket.addEventListener('open', () => {
    if (closed) return;
    openned = true;
    handlers.open(api);
  });
  socket.addEventListener('close', () => {
    if (closed) return;
    closed = true;
    handlers.close(api);
  });
  const onPingTimeout = () => {
    if (closed) return;
    closed = true;
    handlers.close(api);
    socket.close();
  };
  let pingTimeout = setTimeout(onPingTimeout, 3000);
  socket.addEventListener('message', (event) => {
    if (closed) return;
    if (event.data === 'ping') {
      socket.send('pong');
      clearTimeout(pingTimeout);
      pingTimeout = setTimeout(onPingTimeout, 3000);
      return;
    }
    handlers.response(JSON.parse(event.data), api);
  });
  return api;
}

class WebsocketRpcClient {
  constructor(getCsrfToken, server) {
    this._subscriptions = new Map();
    this._methodCallResults = new Map();
    this._inFlightMethodCalls = new Map();
    this._socketReady = false;
    this._nextMessageID = 1;
    this._requestQueue = [];
    this._getCsrfToken = getCsrfToken;
    this._socket = this._connect(server);
  }
  _connect(server) {
    return createWebsocket(server, {
      open: (socket) => {
        this._authenticate(socket);
      },
      response: (response, socket) => {
        switch (response.kind) {
          case types.ResponseKind.Authenticated:
            this._onAuthenticated(socket);
            break;
          case types.ResponseKind.AuthenticationRequired:
            this._onAuthenticationRequired(response, socket);
            break;
          case types.ResponseKind.SubscriptionUpdate:
            this._onSubscriptionUpdate(response);
            break;
          case types.ResponseKind.SubscriptionError:
            console.error(response.message);
            break;
          case types.ResponseKind.MethodCallResult:
            this._onMethodCallResult(response);
            break;
          case types.ResponseKind.MethodCallError:
            this._onMethodCallError(response);
            break;
        }
      },
      close: () => {
        this._socketReady = false;
        const reconnectTime = Math.floor(1000 + Math.random() * 1000);
        console.error(
          `Connection lost, attempting to reconnect in about ${
            Math.round(reconnectTime / 100) / 10
          } seconds`,
        );
        setTimeout(() => {
          this._socket = this._connect(server);
        }, reconnectTime);
      },
    });
  }
  _getMessageID() {
    return this._nextMessageID++;
  }
  _authenticate(socket) {
    this._getCsrfToken().then(
      (token) => {
        if (!socket.isOpen()) return;
        socket.send({
          kind: types.RequestKind.Authenticate,
          token,
          id: this._getMessageID(),
        });
      },
      (err) => {
        if (!socket.isOpen()) return;
        console.error(`Error loading csrf token: ${err.message}`);
        setTimeout(() => {
          this._authenticate(socket);
        }, 1000);
      },
    );
  }
  _onAuthenticated(socket) {
    this._socketReady = true;
    for (const [id, handle] of this._subscriptions) {
      socket.send({
        kind: types.RequestKind.Subscribe,
        id,
        moduleID: handle.moduleID,
        exportName: handle.exportName,
        etag: handle.etag,
      });
    }
    const queue = this._requestQueue;
    this._requestQueue = [];
    for (const request of queue) {
      socket.send(request);
    }
  }
  _onAuthenticationRequired(response, socket) {
    const methodCall = this._inFlightMethodCalls.get(response.id);
    if (methodCall) {
      this._requestQueue.push(methodCall);
      this._inFlightMethodCalls.delete(response.id);
    }
    if (this._socketReady) {
      this._socketReady = false;
      this._authenticate(socket);
    }
  }
  _onSubscriptionUpdate(response) {
    const handler = this._subscriptions.get(response.id);
    if (handler) {
      handler.etag = response.etag;
      handler.onValue(response.value);
    }
  }
  _onMethodCallResult(response) {
    const resolvers = this._methodCallResults.get(response.id);
    if (resolvers) {
      resolvers.resolve(response.value);
    }
    this._methodCallResults.delete(response.id);
    this._inFlightMethodCalls.delete(response.id);
  }
  _onMethodCallError(response) {
    const resolvers = this._methodCallResults.get(response.id);
    if (resolvers) {
      const err = new Error(response.message);
      if (response.code !== null) {
        Object.assign(err, {code: response.code});
      }
      resolvers.reject(err);
    }
    this._methodCallResults.delete(response.id);
    this._inFlightMethodCalls.delete(response.id);
  }
  observableState(moduleID, exportName, initialEtag, initialValue) {
    const id = this._getMessageID();
    const subscribers = new Set();
    let value = initialValue;
    this._subscriptions.set(id, {
      moduleID,
      exportName,
      etag: initialEtag,
      onValue: (newValue) => {
        value = newValue;
        for (const s of subscribers) {
          s(newValue);
        }
      },
    });
    if (this._socketReady) {
      this._socket.send({
        kind: types.RequestKind.Subscribe,
        id,
        moduleID,
        exportName,
        etag: initialEtag,
      });
    }
    return {
      getValue: () => value,
      subscribe: (fn) => {
        subscribers.add(fn);
        return () => subscribers.delete(fn);
      },
    };
  }
  asyncMethod(moduleID, exportName) {
    return async (...args) => {
      return new Promise((resolve, reject) => {
        const id = this._getMessageID();
        this._methodCallResults.set(id, {resolve, reject});
        const request = {
          kind: types.RequestKind.MethodCall,
          id,
          moduleID,
          exportName,
          args,
        };
        if (this._socketReady) {
          this._inFlightMethodCalls.set(id, request);
          this._socket.send(request);
        } else {
          this._requestQueue.push(request);
        }
      });
    };
  }
}

module.exports = WebsocketRpcClient;
